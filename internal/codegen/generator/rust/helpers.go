package rust

import (
	"fmt"
	"strings"

	"github.com/Alia5/VIIPER/internal/codegen/common"
	"github.com/Alia5/VIIPER/internal/codegen/scanner"
)

func goTypeToRust(goType string) string {
	base, isSlice, isPointer := common.NormalizeGoType(goType)
	if base == "any" || base == "interface{}" {
		return "serde_json::Value"
	}

	var rustType string
	switch base {
	case "bool":
		rustType = "bool"
	case "string":
		rustType = "String"
	case "int", "int32":
		rustType = "i32"
	case "int8":
		rustType = "i8"
	case "int16":
		rustType = "i16"
	case "int64":
		rustType = "i64"
	case "uint", "uint32":
		rustType = "u32"
	case "uint8", "byte":
		rustType = "u8"
	case "uint16":
		rustType = "u16"
	case "uint64":
		rustType = "u64"
	case "float32":
		rustType = "f32"
	case "float64":
		rustType = "f64"
	default:
		rustType = common.ToPascalCase(base)
	}

	if isSlice {
		rustType = fmt.Sprintf("Vec<%s>", rustType)
	}
	if isPointer {
		rustType = fmt.Sprintf("Option<%s>", rustType)
	}

	return rustType
}

func parseGoMapType(typeStr string) (keyType string, valueType string, ok bool) {
	if !strings.HasPrefix(typeStr, "map[") {
		return "", "", false
	}
	closeIdx := strings.Index(typeStr, "]")
	if closeIdx < 0 {
		return "", "", false
	}
	keyType = typeStr[len("map["):closeIdx]
	valueType = typeStr[closeIdx+1:]
	if keyType == "" || valueType == "" {
		return "", "", false
	}
	return keyType, valueType, true
}

func wireTypeToRust(wireType string) string {
	baseType := strings.TrimSuffix(wireType, "*")
	if strings.Contains(wireType, "*") {
		idx := strings.Index(wireType, "*")
		baseType = wireType[:idx]
	}

	switch baseType {
	case "u8":
		return "u8"
	case "i8":
		return "i8"
	case "u16":
		return "u16"
	case "i16":
		return "i16"
	case "u32":
		return "u32"
	case "i32":
		return "i32"
	case "u64":
		return "u64"
	case "i64":
		return "i64"
	default:
		return "u8"
	}
}

func isWireArray(spec string) bool {
	return strings.Contains(spec, "*")
}

func extractArrayCount(spec string) string {
	parts := strings.Split(spec, "*")
	if len(parts) == 2 {
		return parts[1]
	}
	return ""
}

func writeFileHeaderRust() string {
	return "// This file is auto-generated by VIIPER codegen. DO NOT EDIT.\n"
}

func toScreamingSnakeCase(s string) string {
	return strings.ToUpper(common.ToSnakeCase(s))
}

func generateMethodParamsRust(route scanner.RouteInfo) string {
	var params []string

	for key := range route.PathParams {
		params = append(params, fmt.Sprintf("%s: u32", common.ToSnakeCase(key)))
	}

	switch route.Payload.Kind {
	case scanner.PayloadJSON:
		paramName := common.ToSnakeCase(route.Payload.ParserHint)
		params = append(params, fmt.Sprintf("%s: &%s", paramName, route.Payload.ParserHint))
	case scanner.PayloadNumeric:
		paramName := common.ToSnakeCase(route.Payload.ParserHint)
		params = append(params, fmt.Sprintf("%s: Option<u32>", paramName))
	case scanner.PayloadString:
		params = append(params, fmt.Sprintf("%s: Option<&str>", common.ToSnakeCase(route.Payload.ParserHint)))
	}

	if len(params) == 0 {
		return ""
	}
	return ", " + strings.Join(params, ", ")
}

func generatePathRust(route scanner.RouteInfo) string {
	path := route.Path
	if len(route.PathParams) == 0 {
		return fmt.Sprintf(`"%s".to_string()`, path)
	}

	var formatStr string
	var args []string

	formatStr = path
	for key := range route.PathParams {
		placeholder := fmt.Sprintf("{%s}", key)
		formatStr = strings.Replace(formatStr, placeholder, "{}", 1)
		args = append(args, common.ToSnakeCase(key))
	}

	if len(args) > 0 {
		return fmt.Sprintf(`format!("%s", %s)`, formatStr, strings.Join(args, ", "))
	}
	return fmt.Sprintf(`"%s".to_string()`, path)
}

func generatePayloadRust(route scanner.RouteInfo) string {
	switch route.Payload.Kind {
	case scanner.PayloadNone:
		return "let payload: Option<String> = None;"
	case scanner.PayloadJSON:
		paramName := common.ToSnakeCase(route.Payload.ParserHint)
		return fmt.Sprintf("let payload = Some(serde_json::to_string(&%s)?);", paramName)
	case scanner.PayloadNumeric:
		paramName := common.ToSnakeCase(route.Payload.ParserHint)
		return fmt.Sprintf("let payload = %s.map(|v| v.to_string());", paramName)
	case scanner.PayloadString:
		paramName := common.ToSnakeCase(route.Payload.ParserHint)
		return fmt.Sprintf("let payload = %s.map(|s| s.to_string());", paramName)
	default:
		return "let payload: Option<String> = None;"
	}
}
